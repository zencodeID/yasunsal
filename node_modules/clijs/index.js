var Lexer =  require('hydro-lexer');
var args  = process.argv;

/**
 * Module exports.
 */

exports = module.exports = cli;

/**
 * Expose `Cli`.
 */

exports.Cli = Cli;

/**
 * Expose `Command`.
 */

exports.Command = Command;

/**
 * Expose `Option`
 */

exports.Option = Option;

/**
 * Interpolate a string
 *
 * Input: '{name}' + 'woot'
 * Output: 'woot'
 *
 */

exports.interpolate = function interpolate(str, input) {
  var ast          = [];
  var bindings     = [];
  var lexer        = Lexer.init()
    .def('string', /^[A-Za-z][A-Za-z0-9-]+$/)
    .def('var', /^({[A-Za-z0-9]+})$/)
    .def('ws', /^[\t \n]$/, true)
    .string(str)
    .start();

  function parse() {
    lexer.next();

    if (lexer.eof) return;

    var token = lexer.token;

    if (token.type === 'var') {

      var val = token.value.match(/\{([A-Za-z0-9]+)\}/, '$1');
      ast.push({
        variable: val && val[1]
      });

      return parse();
    } else if (token.type == 'string') {
      ast.push({
        string: token.value
      });
      return parse();
    }
  }

  parse();

  function compile(value) {
    var words = value.split(' ');

    for (var i = 0; i < words.length; i++) {
      if (!ast[i]) break;
      if (ast[i].string && ast[i].string === words[i]) {
        continue;
      }

      if (ast[i].variable) {
        bindings.push(words[i]);
      }
    }

    return bindings;
  }


  return compile(input);
}

/**
 * Create a new Cli instance.
 */

function cli(name) {
  return new Cli(name);
}

/**
 * Cli Constructor
 */

function Cli(name) {
  this.name = name;
  this._command = new Command(name);
}

/**
 * Bind a function to the current command.
 */

Cli.prototype.fn = function(fn) {
  this._command.fn = fn;
  return this;
};

/**
 * Create a new command
 */

Cli.prototype.command = function(name, fn) {
  return this._command.command(name, fn);
}

/**
 * Add a new option.
 */

Cli.prototype.option = function(name, alias) {
  this.options.push(new Option(name, alias));
  return this;
};

/**
 * Run the cli
 */

Cli.prototype.run = function(args) {
  if (!(args instanceof Array)) {
    throw new Error("An array is needed.");
  }

  // Remove the first two indices:
  args.splice(0, 1);

  // Parse the current command.
  this._command.parse(args);
};

/**
 * Command
 */

function Command(name, fn) {
  if ('string' !== typeof name) {
    throw new Error("name must be a string.");
  }

  this.commands = [];
  this.name = name;
  this.fn = fn;
}

/**
 * Add a new command.
 */

Command.prototype.command = function(name, fn) {
  var cmd = new Command(name, fn);
  this.commands.push(cmd);
  return cmd;
};

/**
 * Parse
 */

Command.prototype.parse = function(args) {
  var cmd = args[1];
  var self = this;
  var found = false;

  this.commands.forEach(function(command) {
    if (command.name === cmd) {
      found = true;
      if (command.fn) {
        command.fn();
      }
    } else {
      // create {name}
      var bindings = exports.interpolate(command.name, cmd);

      if (command.name.split(' ')[0] === cmd.split(' ')[0]) {
        command.fn && command.fn.apply({}, bindings);
        found = true;
      }
    }
  });

  if (!found) {
    throw new Error("The `" + cmd + "` command was not found.");
  }
};

/**
 * Option
 */

function Option(name, alias) {
  this.name  = name;
  this.alias = alias;
}
